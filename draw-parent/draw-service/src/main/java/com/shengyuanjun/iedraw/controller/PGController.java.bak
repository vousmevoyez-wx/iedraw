package com.shengyuanjun.iedraw.controller;

import com.shengyuanjun.iedraw.domain.*;
import com.shengyuanjun.iedraw.service.*;
import com.shengyuanjun.iedraw.test.GenerateCode;
import com.shengyuanjun.iedraw.util.*;
import com.shengyuanjun.iedraw.util.timeUtil.Timeutil;
import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
import net.sf.json.JSONObject;
import org.aspectj.apache.bcel.classfile.Code;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;
import sun.misc.Cache;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.*;


/**
 * @program: gongzhongget
 * @description:
 * @author: gq544
 * @create: 2019-08-03 16:28
 */
@RestController
@PropertySource("classpath:constants/constant.properties")
@RequestMapping("/wx")
public class PGController {

    private static final Logger logger = LoggerFactory.getLogger(PGController.class);

    //获取用户信息
    @Resource
    private UserInfoService userinfoServiceImpl;

    @Resource
    private IPrizeRecordService prizeRecordServiceImpl;

    @Autowired
    private ITokenuserService tokenuserService;

    @Resource
    private IPrizeService prizeServiceImpl;

    @Resource
    private TokenService tokenServiceImpl;

    @Resource
    private ICustomizeService customizeServiceImpl;

    @Resource
    private IQuotationsService quotationsServiceImpl;

    @Resource
    private IParticipationRestrictionService participationRestrictionServiceImpl;

    @Value("${url.project}")
    private String pjurl;//项目的IP地址&域名

    @Value("${url.active}")
    private String h5url;

    @Value("${gzh.coderedirecturl}")
    private String redirecturl;


    @Value("${gzh.appid}")
    private String appid;

    @Value("${url.prizeurl}")
    private String gopsaveurl;

    @Value("${url.winprizecodeurl}")
    public String winprizeurl;

    /**
     * @Description: 判断请求必须来自微信才能打开进入H5活动页面, 不能通过外部浏览器直接输入H5地址进入活动页面
     * @Param: [response, request]
     * @return: void
     * @Author: gq544
     * @date: 2019/8/7 22:28
     */
    @RequestMapping(value = "/active", method = RequestMethod.GET)
    public String backActive(HttpServletResponse response, HttpServletRequest request) {
        System.out.println("判断结果为 " + MessageFrom.msgFrom(request));
        try {
            if (MessageFrom.msgFrom(request)) {//判断请求是否来自于微信端
                response.sendRedirect(h5url);
            } else {
                logger.info("本次请求不是来自微信端，需要重新到微信端进行访问。。。");
                return "本次请求不是来自微信端，需要重新到微信端进行访问。";
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "";
    }

    /**
     * 01
     *
     * @Description: 来自微信的请求，首先让前端需要通过授权获取code，来换取用户信息
     * @Param: [response]
     * @Author: gq544
     * @date: 2019/8/5 21:48
     */
    @RequestMapping(value = "/pgcode", method = RequestMethod.GET)
    public String toGetCode(HttpServletResponse response, HttpServletRequest request) {
        String junpurl = "";
        try {
            //判断请求是否来自于微信端
            boolean bo = MessageFrom.msgFrom(request);
            //如果bo为true则来自微信，反之不是来自微信。。。;
            if (bo) {
                //通过微信端访问进来的请求回调请求获取code，redirect_url进行URLEncoder处理
                String callbackurl = URLEncoder.encode(redirecturl, "UTF-8");
                junpurl = "https://open.weixin.qq.com/connect/oauth2/authorize?appid=" + appid + "&redirect_uri=" + callbackurl + "&response_type=code&scope=snsapi_base&state=123&connect_redirect=#wechat_redirect";

                //在前端重定向到回调函数获取授权code
                response.sendRedirect(junpurl);
            } else {
                //如果不是微信登录，跳转到项目下提示页面
                logger.info("本次请求不是来自微信端，需要重新到微信端进行访问。。。");
                junpurl = "非微信端无法访问此页面，请到微信端进行访问。";
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return "fail";
        } catch (IOException e) {
            e.printStackTrace();
            return "fail";
        }
        return junpurl;
    }



    /**
     * 02
     *
     * @Description: 前端页面网页授权后，获取code并发送给后台，在此方法换取用户openid，如果符合要求，则保存用户信息
     * 获取code之后。通过  https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code
     * @Param: [request, response]
     * @return: java.lang.String 返回状态码   返回userid=0表示用户未关注，userid=-1表示用户信息获取发生异常
     * @Author: gq544
     * @date: 2019/8/4 13:54
     */
    @RequestMapping(value = "/pgopen", method = RequestMethod.GET)
    @ResponseBody
    public String GetGZHOpenid(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession();
        String tokenaccess = "2222222";
        String value = "1";
        //预防重复请求
        if (session.getAttribute("code") == null) {
            String code = request.getParameter("code");//获取code
            if (!code.equals(session.getAttribute("code"))) {
                logger.info("获取code并申请获得openid...code = " + code);
                //session.setAttribute("code", code);
                System.out.println("code =" + code);
                Map codemap = userinfoServiceImpl.getOpenid(code);
                String openid = (String)codemap.get("openid");
                String opemidaccesstoken = (String)codemap.get("accesstoken");

                System.out.println("openid = "+openid);

                System.out.println("accesstoken = "+opemidaccesstoken);

                //获取openid之后通过官方接口查询用户基本信息
                //从数据库中获取此时的access_token

                AccessToken accesstoken = tokenServiceImpl.getAccessTokenFromDBById(1);
                String token = accesstoken.getAccesstoken();
                if(accesstoken == null){

                    tokenaccess = tokenaccess+"accesstoken查询为空";

                }else{
                    tokenaccess = "这是token..  ： "+token;
                }
                //通过openid和accesstoken获取用户的基本信息
                logger.info(" /pgopen 使用openid 获取用户基本信息userinfo。。。。。。。。。。。。");
                JSONObject json = userinfoServiceImpl.getSNSUserInfo(token, openid);
                if (json.toString().contains("access_token is invalid or not latest hint")) {
                    //如果accesstoken过期，重新获取并保存
                    logger.info("验证用户信息token失效，重新获取token");
                    AccessToken tokens = new AccessToken();
                    tokens.setAccesstoken(tokenServiceImpl.getAccess_token());
                    tokens.setId(1);
                    tokenServiceImpl.updateToken(tokens);
                    return "{\"userid\":\"-100\"}";
                }
                try {
                    if(json.toString().contains("subscribe")){
                        if ("1".equals(json.getString("subscribe"))) {
                            //如果用户已经关注公众号，则执行用户信息比对录入
                            System.out.println(json);
                            UserInfo user = new UserInfo();

                            user.setHeadimgurl(json.getString("headimgurl"));
                            user.setOpenid(json.getString("openid"));
                            user.setNickname(json.getString("nickname"));
                            user.setSex(new Byte(json.getString("sex")));
                            user.setSubscribe(new Byte(json.getString("subscribe")));

                            String nowtime = Timeutil.getLongTime();

                            user.setCreatetime(Long.parseLong(nowtime));

                            UserInfo backuser = new UserInfo();
                            //通过用户openid查找用户信息
                            backuser = userinfoServiceImpl.selectThisUser(openid);
                            System.out.println("user = " + backuser);
                            //校验是否已经录入资料结果
                            //如果数据库没有该用户信息，则执行保存
                            if (backuser == null) {
                                logger.info("没有查到该用户信息，执行保存操作...");
                                userinfoServiceImpl.saveUserInfomsg(user);
                                System.out.println("userid = " + user.getId());
                                return "{\"userid\":\"" + user.getId() + "\"}";
                            }
                            logger.info("该用户已关注公众号，信息校验成功。。。");
                            return "{\"userid\":\"" + backuser.getId() + "\"}";
                        } else {
                            logger.info("该用户并未关注。。。。。。。。。");
                            return "{\"userid\":\"0\"}";
                        }
                    }else{
                        return "{\"userid\":\"" + "  tokenaccessshow = "+ tokenaccess +"     后台拿到的code = " + code + "      code请求获取openid的value1 = "+json+"          openid换取用户信息的value2 = " + codemap.get("value") + "\"}";
                    }
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                    logger.info("用户数据处理失败。。。。。。...");
                    return "{\"userid\":\"-1\"}";
                }
            }
            // }
            return value;
        }
        return value;
    }


    /**
     * 03
     *
     * @Description: 获奖结果保存, (单个奖品传递)/通过type判断奖品类型，私人定制生成提货码，普通奖品生成二维码，有赞优惠券直接保存有赞,返回一个Prize 的Json对象
     * @Param: [id  奖品id   ，
     * @return: java.lang.String
     * @Author: gq544
     * @date: 2019/8/6 11:03
     * return  map(status,value)  如果status为-1，用户id获取错误，0，用户未关注公众号，   1，用户信息正常，已成功获取用户id
     *                                  2：超出当日次数    3：超出总抽奖次数    4： 不在活动范围内
     */
    @RequestMapping(value = "/prizval", method = RequestMethod.GET,produces = "application/json;charset=UTF-8")
    @ResponseBody
    @Transactional  //添加事务管理
    public Map savePrizeValue(HttpServletRequest request,String userid) {

        String testmsg = "";



        Map map = new HashMap();
        if(Integer.parseInt(userid) < 0){
            map.put("status","-1");
            return map;
        }else if(Integer.parseInt(userid) == 0){
            map.put("status","0");
            return map;
        }

        System.out.println("定位确认");

        System.out.println("参数  = " +request.getParameterMap()  );

        System.out.println("url = " + request.getRequestURL());

      String longitude0 =  request.getParameter("longitude");
        String latitude0 =  request.getParameter("latitude");
        System.out.println("longitude0 = "+longitude0);

        System.out.println("latitude0 = "+latitude0);
        logger.info("longitude0 ======= " + longitude0);
        logger.info("latitude0 ====== " + latitude0);

        ParticipationRestriction par = participationRestrictionServiceImpl.selectParticipationRestrictionById(Long.parseLong("3"));
       String range = par.getRange();//系统范围
        //判断是否在活动的地图范围内
        double distence = CalulateTwoLanLon.getDistance(Double.parseDouble(longitude0),Double.parseDouble(latitude0),Double.parseDouble(par.getLongitude()),Double.parseDouble(par.getLatitude()));
        distence = distence * 1000;



        logger.info("Double.parseDouble(longitude0) = " + Double.parseDouble(longitude0));
        logger.info("Double.parseDouble(latitude0) = " + Double.parseDouble(latitude0));
        logger.info("Double.parseDouble(par.getLongitude()) = " + Double.parseDouble(par.getLongitude()));
        logger.info("Double.parseDouble(par.getLatitude()) = " + Double.parseDouble(par.getLatitude()));

        logger.info("distence = " + distence);
        logger.info("Double.parseDouble(par.getRange() = " + Double.parseDouble(par.getRange()));


        if (distence <= Double.parseDouble(par.getRange())) {
            logger.info("判断的值在范围以内");
            /*HttpSession session = request.getSession();
            //zaisession中获取openid来查询用户信息
            String openid = (String) session.getAttribute("openid");*/

            System.out.println("userid = "+ userid);

            UserInfo user = userinfoServiceImpl.selectUserById(Long.parseLong(userid));
            //查询日抽奖上限
            String dailytimes = par.getDayparticipation();

            //查询总参与次数
            String uploaduTimes = par.getTotalparticipants();

            System.out.println("user = " + user);

            //查询本人抽奖次数111
            List<PrizeRecord> pzr = prizeRecordServiceImpl.selectWinTimesDaily();
            List<PrizeRecord> list = new Vector<PrizeRecord>();
            //如果总次数没有超，则判断当天总次数
            if (pzr.size() < Integer.parseInt(uploaduTimes)) {
                //获取现在时间
                String nowtm = Timeutil.getLongTime();
                Iterator<PrizeRecord> it = pzr.iterator();
                System.out.println("pzr = " + pzr);
                while (it.hasNext()) {
                    PrizeRecord p = it.next();
                    //用于记录当天记录次数
                    //工具类转换时间戳为日期,确定当天有效
                    if (Timeutil.getDayTime(new Date().getTime() + "").equals(Timeutil.getDayTime(p.getCreatetime() + "")) && p.getUserid() == user.getId()) {
                        System.out.println("p = " + p);
                        list.add(p);
                    }
                }
                if (list.size() > Integer.parseInt(dailytimes)) {
                    map.put("status","2");
                    return map;
                }
        /*
           状态判定:0为有赞，
                    1为奖品
                    2为私人定制
         */

                map.put("status","1");

                ArrayList<Prize> prizes = prizeServiceImpl.selectAllPrize();
                int i = 0;
                int[] result = new int[4];
                //遍历所有奖品
                Iterator<Prize> iter = prizes.iterator();
                //存放有货的奖品
                ArrayList<Prize> AP = new ArrayList<>();
                float obbchange = 0;

                //抽奖前库存判断
                while(iter.hasNext()){
                    Prize p= iter.next();
                    Prize tem = new Prize();
                    tem.setId(p.getId());
                    tem.setType(p.getType());
                    tem.setPrizename(p.getPrizename());
                    tem.setPictureurl(p.getPictureurl());
                    tem.setOdds(p.getOdds());
                    tem.setStock(p.getStock());
                    tem.setBeginvalidityperiod(p.getBeginvalidityperiod());
                    tem.setEndvalidityperiod(p.getEndvalidityperiod());

                    if(tem.getStock()<=0){
                        obbchange = obbchange + tem.getOdds();
                        tem.setOdds((float) 0);
                    }
                    AP.add(tem);
                }

                List<Prize> prizeList = new  ArrayList<Prize>();
                System.out.println("obbchange = " + obbchange);
                Iterator<Prize> ite = AP.iterator();
                int count = 0 ;
                while(ite.hasNext()){
                    Prize p= ite.next();
                    if(p.getType()==0 && count==0 && obbchange > 0){
                        p.setOdds(p.getOdds()+obbchange);
                        count++;
                    }
                    prizeList.add(p);
                }
                System.out.println("prizeList="+prizeList.toString());

                System.out.println("抽奖开始");
                //根据参数进入抽奖工具类进行该路计算
                int selected = 0;
                Prize pz1 = null;

                    selected = DrawUtil.getPrizeIndex(prizeList);

                    //结果奖品
                    pz1 = prizes.get(selected);
                System.out.println("prizes = " + prizes.toString());
                    System.out.println("抽中的奖品为：" + pz1);
                    System.out.println("------------------------------------------------------");
                    System.out.println("抽奖结束");

                PrizeRecord pz = new PrizeRecord();

                pz.setUserid(user.getId());
                pz.setPrizeid(prizes.get(selected).getId());

                Long time = new Date().getTime();

                pz.setCreatetime(time);
                pz.setStatus(0);
                pz.setIsdel(1);

                System.out.println("继续走,pp.name = "+pz1.getPrizename());
                /*
                    类型： 0表示优惠券
                    类型： 1表示私人定制
                    类型： 2表示奖品
                 */
                if (pz1.getType()==0) {

                    testmsg = testmsg + "0000";
                    System.out.println("这优惠券");
                    pz.setGoodscode("有赞");
                    pz.setType(0);

                    //保存到中奖记录
                    prizeRecordServiceImpl.savePrizeRecord(pz);
                } else if (pz1.getType()==1) {
                    testmsg = testmsg + "1111";
                    System.out.println("这提货码奖品");
                    String number = NameUtil.genNumberStr(5);
                    PrizeRecord p1 = new PrizeRecord();
                    p1.setGoodscode(number);
                    p1.setType(1);
                    //判断这个商品提货码是否存在，如果不存在，则保存，。如果存在，重新生成提货吗
                    boolean bo = true;
                    //如果该码用过，则重新生成
                    while (bo) {
                        System.out.println("判断bo的值,其中  p1 = " + p1);
                        bo = (prizeRecordServiceImpl.selectGetNumber(p1) != null);
                        System.out.println("bo = " + bo);
                        if (!bo) {
                            pz.setGoodscode(number);
                            Customize cu = new Customize();
                            //cu.setGoodscode(number);

                            String thistime = Timeutil.getLongTime();

                            //cu.setCreatetime(Long.parseLong(thistime));
                            pz.setType(1);

                            //保存到中奖记录
                            prizeRecordServiceImpl.savePrizeRecord(pz);
                           // customizeServiceImpl.addCustomize(cu);
                            break;
                        }
                        number = NameUtil.genNumberStr(5);
                        System.out.println("again。。。");
                        p1.setGoodscode(number);
                    }
                } else if (pz1.getType()==2) {
                    testmsg = testmsg + "222222";
                    System.out.println("这是个奖品");
                    pz.setType(2);

                    prizeRecordServiceImpl.savePrizeRecord(pz);

                    Long pzid = pz.getId();

                    //随机字符串拼接时间戳生成唯一二维码图片文件名称
                    String codeName = NameUtil.generateMixStr(6) + new Date().getTime() + "";

                    String jsonmsg = "{\"id\":\"" + pzid + "\",\"status\": \"0\"}";

                    GenerateCode.generateCode(gopsaveurl, jsonmsg, codeName);

                    PrizeRecord p = new PrizeRecord();
                    //设置对象id和url
                    p.setGoodscode(winprizeurl + gopsaveurl + "/" + codeName + ".png");
                    p.setId(pzid);
                    //对应保存url信息
                    prizeRecordServiceImpl.savePrizeRecordQRCode(p);
                }
                //抽奖后奖品数量减1
                System.out.println("pz1 = "+pz1);
                pz1.setStock(pz1.getStock()-1);
                prizeServiceImpl.updateStockByPrizeWinner(pz1);

                System.out.println("prize = "+pz1);

                System.out.println("prize = " + pz1);

                logger.info("用户查询结果为 " + user);
                map.put("winner", pz1);
                map.put("msg",testmsg);
                System.out.println(map.toString());
                return map;
            }else{
                //超出总次数
                map.put("status","3");
                return map;
            }
        } else {
            //超出范围
            map.put("status","4");
            return map;
        }
    }




    /*
    用户查询自己的中奖记录的方法
    -1表示用户信息获取失败
    0表示用户信息不存在
    status=1表示用户信息正常获取并且附带一个PrizeRecord对象
 */
    @RequestMapping("/shmin")
    public Map getit(HttpServletRequest request,String userid){
        Map map = new HashMap();
        if(Integer.parseInt(userid) < 0){
            map.put("status","-1");
            return map;
        }else if(Integer.parseInt(userid) == 0){
            map.put("status","0");
            return map;
        }
        System.out.println("进来  userid = " + userid);
        //前端传递回来userid。后端查看用户身份
       //String userid = request.getParameter("userid");
        System.out.println("URL = " + request.getRequestURL());
        System.out.println("userid = " + userid);
        UserInfo user = userinfoServiceImpl.selectUserById(Long.parseLong(userid));

        /*HttpSession session = request.getSession();
        String openid = (String)session.getAttribute("openid");
        UserInfo user = userinfoServiceImpl.selectThisUser(openid);*/

        List<PrizeRecord> prc = prizeRecordServiceImpl.selectTwoTableByUserId(user.getId());
        Iterator<PrizeRecord> it = prc.iterator();
        while(it.hasNext()){
            System.out.println("value = "+it.next());
        }
        map.put("status","1");
        map.put("PrizeRecord",prc);
        System.out.println(map);
        System.out.println("map  = " + map);
        return map;
    }


    /**
     * 00001
     *@Description: 通过前段传递过来的状态返回对应语句 6条
     *@Param: [status]
     *@return: java.util.List<com.example.gzher.entitys.Quotations>
     *@Author: gq544
     *@date: 2019/8/9 1:43
     */
    @RequestMapping("/words")
    public Map  backWords(String status,String token){

        Map map = new HashMap();
        System.out.println("token = " + token);
        Tokenuser tokenu = tokenuserService.selectByToken(token);
        System.out.println("tokenu  = " + tokenu );
        if (tokenu==null){
            map.put("code0","201");
            map.put("msg","token验证失败");
            map.put("success",false);
            return map;
        }else{
            if((new Date().getTime() - tokenu.getTokenDate().getTime()) > 60*60*1000){
                map.put("code0","201");
                map.put("msg","token已失效");
                map.put("success",false);
                return map;
            }else{
                tokenu.setTokenDate(new Date());
                tokenuserService.updateById(tokenu);
            }
        }

        Long statu = Long.parseLong(status);
        List<Quotations> qlist = quotationsServiceImpl.selectQuotationsByStatus(statu);
        System.out.println("value = " + qlist);

        List<Integer> indexList = new Vector<>();
        //通过status来选取对应语句
        for(int i = 0 ; i < qlist.size() ; i++){
            indexList.add(i);
        }

        List<Quotations> list = new Vector<>();
        Random r = new Random();
        if(indexList.size() <= 0){
            map.put("code0","201");
            map.put("msg","获取失败");
            map.put("success",false);
            return map;
        }
        for(int j = 0 ; j < 6 ; j++){
            int index = r.nextInt(indexList.size());
            list.add(qlist.get(indexList.get(index)));
            indexList.remove(index);
        }
        //200成功   201 失败
        if(list.size()>0){
            map.put("code0","200");
            map.put("data",list);
            map.put("msg","获取成功");
            map.put("success",true);
        }else{
            map.put("code0","201");
            map.put("msg","获取失败");
            map.put("success",false);
        }

        return map;
    }


}